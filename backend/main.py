from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
import uuid
from pathlib import Path
import numpy as np
from fastapi.middleware.cors import CORSMiddleware
import networkx as nx

import os
import random
from datetime import datetime
from logging_conf import get_room_logger

app = FastAPI()
# Default edge weights
W_PP = 0.0  # player-player
W_NN = 1.0  # neutral-neutral
W_PN = 2.0  # player-neutral
INITIAL_POINT_WEIGHT = 1.0  # Initial point weight for new edges

import networkx as nx

# Compute node positions using force-directed layout
def get_pos(nodes, edges):
    G = nx.Graph()
    for node in nodes:
        G.add_node(node["id"])
    for edge in edges:
        G.add_edge(edge["source"], edge["target"], weight=edge["weight"])

    # Use Kamada-Kawai layout
    pos = nx.kamada_kawai_layout(G)

    # Normalize positions to fit within the 0-1 range
    x_coords, y_coords = zip(*pos.values())
    min_x, max_x = min(x_coords), max(x_coords)
    min_y, max_y = min(y_coords), max(y_coords)

    def normalize(val, min_val, max_val):
        return (val - min_val) / (max_val - min_val) if max_val > min_val else 0.5

    normalized_pos = {
        node: (
            normalize(p[0], min_x, max_x) * 0.8 + 0.1, # Scale and shift to avoid edges
            normalize(p[1], min_y, max_y) * 0.8 + 0.1
        )
        for node, p in pos.items()
    }
    return normalized_pos

# Load default icon names for players and neutrals
BASE_DIR = Path(__file__).parent
try:
    with open(BASE_DIR / 'default_players.txt') as f:
        DEFAULT_PLAYER_ICONS = [line.strip() for line in f if line.strip()]
except Exception:
    DEFAULT_PLAYER_ICONS = []
try:
    with open(BASE_DIR / 'default_neutrals.txt') as f:
        DEFAULT_NEUTRAL_ICONS = [line.strip() for line in f if line.strip()]
except Exception:
    DEFAULT_NEUTRAL_ICONS = []

# Add CORS middleware
frontend_url = os.environ.get("FRONTEND_URL", "*") # Default to * for local development
app.add_middleware(
    CORSMiddleware,
    allow_origins=[frontend_url],  # Allows specific origin from environment variable
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

# --- WebSocket Connections ---
connections: Dict[str, List[WebSocket]] = {}

async def broadcast_message(room_id: str, message: Dict[str, Any]):
    if room_id in connections:
        # Create a copy of the list to avoid issues with concurrent modification
        # if a client disconnects during iteration
        for connection in list(connections[room_id]):
            try:
                await connection.send_json(message)
            except RuntimeError: # Client disconnected
                if connection in connections[room_id]:
                    connections[room_id].remove(connection)
                if not connections[room_id]:
                    del connections[room_id]

# --- Models ---
class Player(BaseModel):
    id: str
    name: str
    score: float = 0.0
    x: float = 0.0  # normalized x position (0.0 to 1.0)
    y: float = 0.0  # normalized y position (0.0 to 1.0)
    x_str: str = ""  # x as percentage string (e.g., '50%')
    y_str: str = ""  # y as percentage string
    icon: str = ""  # icon identifier for representing node
    location: str = ""  # current UI screen identifier
    out_deg: int = 0  # outgoing degree sum
    in_deg: int = 0   # incoming degree sum
    is_ai: bool = False
class LocationUpdateRequest(BaseModel):
    location: str

class Turn(BaseModel):
    id: str  # generated by server
    adj_matrix: List[List[float]]  # adjacency matrix for the graph
    completed: bool = False  # whether this turn has been completed

class Neutral(BaseModel):
    id: str
    name: str
    score: float = 0.0
    x: float = 0.0
    y: float = 0.0
    x_str: str = ""
    y_str: str = ""
    icon: str = ""
    out_deg: int = 0  # outgoing degree sum
    in_deg: int = 0   # incoming degree sum

class Move(BaseModel):
    id: int  # generated by server
    player_id: str
    source: str
    target: str
    weight_change: int
    note: Optional[str] = None

class ResetMovesRequest(BaseModel):
    player_id: str

# Request schema for renaming a player
class RenamePlayerRequest(BaseModel):
    new_name: str

# Input model for creating a move without an id
class MoveIn(BaseModel):
    player_id: str
    source: str
    target: str
    weight_change: int
    note: Optional[str] = None

class Room(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str

    num_players_N: int = 1  # Default to 1 player
    num_non_player_nodes_M: int = 2 # Default to 2 non-player nodes
    points_per_round_K: int = 10 # Default to 10 points per round
    max_turns_S: int = 10 # Default to 10 turns
    players: List[Player] = []
    neutrals: List[Neutral] = []  # list of non-player nodes


    graph: Dict[str, Any] = {"nodes": [], "edges": []}
    moves: List[Move] = []
    turn: int = 1
    submitted_moves_points: Dict[str, int] = {}
    ai_move_notes: Dict[str, List[str]] = Field(default_factory=dict)
    turns: Dict[str, Turn] = {}
    moves_history: Dict[int, List[Move]] = Field(default_factory=dict)  # moves grouped by turn number

# --- In-memory database ---
rooms: Dict[str, Room] = {}

# --- Helper Functions ---

def _pick_weighted_edge(edges: List[Dict[str, Any]], *, prefer_low_weight: bool) -> Optional[Dict[str, Any]]:
    """Return a representative edge either from the lightest or heaviest group."""
    if not edges:
        return None
    sorted_edges = sorted(
        edges,
        key=lambda e: float(e.get("weight", 0.0)),
        reverse=not prefer_low_weight,
    )
    window_size = min(3, len(sorted_edges))
    return random.choice(sorted_edges[:window_size])


def _incoming_edges(room: Room, target_id: str, preferred_sources: set[str] | None = None) -> List[Dict[str, Any]]:
    edges = [edge for edge in room.graph.get("edges", []) if edge.get("target") == target_id]
    if preferred_sources:
        prioritized = [edge for edge in edges if edge.get("source") in preferred_sources]
        if prioritized:
            return prioritized
    return edges


def _select_competitor(room: Room, ai_player_id: str) -> Optional[Player]:
    opponents = [p for p in room.players if p.id != ai_player_id]
    if not opponents:
        return None
    return max(opponents, key=lambda p: p.score or 0.0)


def _node_label(room: Room, node_id: str) -> str:
    for p in room.players:
        if p.id == node_id:
            return p.name
    for n in room.neutrals:
        if n.id == node_id:
            return n.name
    return node_id


def populate_ai_moves(room: Room):
    """Ensure every AI player has submitted moves for the current turn."""
    if not room.players:
        return
    node_edges = room.graph.setdefault("edges", [])
    neutral_ids = {n.id for n in room.neutrals}
    next_move_id = max((m.id for m in room.moves), default=0) + 1

    for player in room.players:
        if not player.is_ai:
            continue
        room.ai_move_notes[player.id] = []
        current_spent = room.submitted_moves_points.get(player.id, 0)
        budget = room.points_per_round_K - current_spent
        if budget <= 0:
            # Already submitted this round
            if player.location != "Waiting":
                player.location = "Waiting"
            continue

        ai_moves_payload = []

        # Split effort between boosting own inbound edges and weakening the top opponent
        boost_budget = max(1, (budget * 3) // 4)
        sabotage_budget = budget - boost_budget

        competitor_edge = None
        competitor: Optional[Player] = None
        if sabotage_budget > 0:
            competitor = _select_competitor(room, player.id)
            if competitor:
                opponent_edges = _incoming_edges(room, competitor.id, neutral_ids)
                competitor_edge = _pick_weighted_edge(opponent_edges, prefer_low_weight=False)
            if competitor_edge is None:
                boost_budget += sabotage_budget
                sabotage_budget = 0

        incoming = _incoming_edges(room, player.id, neutral_ids)
        if not incoming:
            incoming = _incoming_edges(room, player.id)
        if not incoming:
            fallback_edge = {"source": player.id, "target": player.id, "weight": 0.0}
            node_edges.append(fallback_edge)
            incoming = [fallback_edge]

        boost_edge = _pick_weighted_edge(incoming, prefer_low_weight=True)
        if boost_edge is None:
            continue

        boost_source = _node_label(room, boost_edge["source"])
        boost_target = _node_label(room, boost_edge["target"])
        boost_note = f"Boosted {boost_source}→{boost_target} by +{boost_budget} to fortify own inflow."

        move_obj = Move(
            id=next_move_id,
            player_id=player.id,
            source=boost_edge["source"],
            target=boost_edge["target"],
            weight_change=boost_budget,
            note=boost_note,
        )
        room.moves.append(move_obj)
        ai_moves_payload.append(move_obj.dict())
        room.ai_move_notes[player.id].append(boost_note)
        next_move_id += 1

        if sabotage_budget > 0 and competitor_edge is not None:
            competitor = next((p for p in room.players if p.id == competitor_edge["target"]), None)
            competitor_name = competitor.name if competitor else _node_label(room, competitor_edge["target"])
            sab_source = _node_label(room, competitor_edge["source"])
            sab_target = _node_label(room, competitor_edge["target"])
            sabotage_note = (
                f"Weakened {competitor_name}'s inflow {sab_source}→{sab_target} by {sabotage_budget} to slow their score."
            )
            move_obj = Move(
                id=next_move_id,
                player_id=player.id,
                source=competitor_edge["source"],
                target=competitor_edge["target"],
                weight_change=-sabotage_budget,
                note=sabotage_note,
            )
            room.moves.append(move_obj)
            ai_moves_payload.append(move_obj.dict())
            room.ai_move_notes[player.id].append(sabotage_note)
            next_move_id += 1

        room.submitted_moves_points[player.id] = room.points_per_round_K
        player.location = "Waiting"

        if ai_moves_payload:
            logger = get_room_logger(room.id)
            logger.info(
                "ai_moves",
                extra={
                    "ts": datetime.now().isoformat(timespec="milliseconds"),
                    "round": room.turn,
                    "player": player.id,
                    "moves": ai_moves_payload,
                },
            )

def get_room_safe(room_id: str) -> Room:
    if room_id not in rooms:
        raise HTTPException(status_code=404, detail="Room not found")
    return rooms[room_id]

async def _calculate_scores_and_advance_turn(room_id: str):
    room = get_room_safe(room_id)

    # 1. Consolidate and apply moves to the graph
    consolidated_moves: Dict[tuple[str, str], int] = {}
    for move in room.moves:
        edge_key = (move.source, move.target)
        consolidated_moves[edge_key] = consolidated_moves.get(edge_key, 0) + move.weight_change

    print(f"Applying consolidated moves: {consolidated_moves}")
    for edge in room.graph["edges"]:
        edge_key = (edge["source"], edge["target"])
        if edge_key in consolidated_moves:
            net_change = consolidated_moves[edge_key]
            new_weight = int(edge["weight"] + net_change)
            edge["weight"] = max(0, new_weight)
    print("Graph after moves:", room.graph)

    # 2. Create transition matrix
    node_ids = [node["id"] for node in room.graph["nodes"]]
    node_index = {name: i for i, name in enumerate(node_ids)}
    matrix_size = len(node_ids)
    adj_matrix = np.zeros((matrix_size, matrix_size))

    for edge in room.graph["edges"]:
        u, v = node_index[edge["source"]], node_index[edge["target"]]
        # Adjacency matrix構築時に、重みが0の場合は0.01に置き換える
        weight = max(0.01, float(edge["weight"]))
        adj_matrix[u, v] = weight
    print("Adjacency Matrix:\n", adj_matrix)
    # Assign adjacency matrix to the current turn
    room.turns[str(room.turn)].adj_matrix = np.where(adj_matrix == 0.1, 0, adj_matrix).tolist()
    room.turns[str(room.turn)].completed = True

    # Compute out/in degrees from adjacency matrix
    row_sums1d = adj_matrix.sum(axis=1)
    col_sums1d = adj_matrix.sum(axis=0)
    # Assign degrees to players
    for player in room.players:
        idx = node_index.get(player.id)
        if idx is not None:
            player.out_deg = int(row_sums1d[idx])
            player.in_deg = int(col_sums1d[idx])
    # Assign degrees to neutrals
    for neutral in room.neutrals:
        idx = node_index.get(neutral.id)
        if idx is not None:
            neutral.out_deg = int(row_sums1d[idx])
            neutral.in_deg = int(col_sums1d[idx])

    # Normalize to get transition matrix
    row_sums = adj_matrix.sum(axis=1, keepdims=True)
    print("Row Sums:\n", row_sums)
    # Avoid division by zero for isolated nodes
    row_sums[row_sums == 0] = 1
    transition_matrix = adj_matrix / row_sums
    print("Transition Matrix:\n", transition_matrix)

    # 3. Calculate stationary distribution (eigenvector for eigenvalue 1)
    eigenvalues, eigenvectors = np.linalg.eig(transition_matrix.T)
    print("Eigenvalues:\n", eigenvalues)
    print("Eigenvectors:\n", eigenvectors)
    stationary_vector = None
    for i, eigenvalue in enumerate(eigenvalues):
        if np.isclose(eigenvalue, 1):
            stationary_vector = np.real(eigenvectors[:, i])
            break

    if stationary_vector is None:
        raise HTTPException(status_code=500, detail="Could not find stationary distribution")

    stationary_distribution = stationary_vector / stationary_vector.sum()
    print("Stationary Distribution:\n", stationary_distribution)

    # 4. Update node scores from stationary distribution
    all_node_scores = {node_id: stationary_distribution[i] for node_id, i in node_index.items()}
    # Update player scores by id
    for player in room.players:
        if player.id in all_node_scores:
            player.score = all_node_scores[player.id]
            print(f"Player {player.name} ({player.id}) score updated to: {player.score}")
    # Update neutral scores by id, if needed
    for neutral in room.neutrals:
        if neutral.id in all_node_scores:
            neutral.score = all_node_scores[neutral.id]
            print(f"Neutral {neutral.name} ({neutral.id}) score updated to: {neutral.score}")

    # Logger ------------------------------------------------------------------
    logger = get_room_logger(room_id)
    logger.info(
        "scores_round",
        extra={
                "ts": datetime.now().isoformat(timespec="milliseconds"),
            "round": room.turn,
            "adj_matrix": adj_matrix.tolist(),
            "stationary_dist": stationary_distribution.tolist(),
            "scores": {p.id: p.score for p in room.players},
        },
    )
    # -------------------------------------------------------------------------

    # 5. Save moves to history before reset
    room.moves_history[room.turn] = list(room.moves)

    # 6. Reset for next turn
    room.moves = []
    room.turn += 1
    room.submitted_moves_points = {}

    # Ensure graph nodes and edges are lists before broadcasting
    if "nodes" not in room.graph or not isinstance(room.graph["nodes"], list):
        room.graph["nodes"] = []
    if "edges" not in room.graph or not isinstance(room.graph["edges"], list):
        room.graph["edges"] = []

    if room.turn > room.max_turns_S: # Game over condition
        # Sort players by score for ranking
        ranked_players = sorted(room.players, key=lambda p: p.score, reverse=True)
        game_over_message = {
            "type": "game_over",
            "room": room.dict(),
            "ranking": [{"id": p.id, "name": p.name, "score": p.score} for p in ranked_players],
            "all_node_scores": all_node_scores
        }

        # Logger --------------------------------------------------------------
        logger.info(
            "game_over",
            extra={
                "ts": datetime.now().isoformat(timespec="milliseconds"),
                "final_ranking": [
                    {"id": p.id, "name": p.name, "score": p.score}
                    for p in ranked_players
                ],
            },
        )
        # ---------------------------------------------------------------------

        await broadcast_message(room_id, game_over_message)
        # Room deletion is handled via the DELETE /rooms/{room_id} endpoint
    else:
        populate_ai_moves(room)
        await broadcast_message(room_id, {"type": "scores_calculated", "room": room.dict()})


# --- API Endpoints ---

@app.get("/")
def read_root():
    return {"message": "Welcome to Markovian Royale API"}

class RoomCreate(BaseModel):
    name: str

    num_players_N: int = 2
    num_non_player_nodes_M: int = 2
    points_per_round_K: int = 10
    max_turns_S: int = 10
    ai_player_positions: List[int] = Field(default_factory=list)

@app.post("/rooms", response_model=Room, status_code=201)
@app.post("/rooms", response_model=Room, status_code=201)
def create_room(room_data: RoomCreate):
    # Validate AI designations before building the room
    unique_ai_positions = sorted(set(room_data.ai_player_positions))
    invalid_positions = [pos for pos in unique_ai_positions if pos < 1 or pos > room_data.num_players_N]
    if invalid_positions:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid ai_player_positions: {invalid_positions}."
        )
    ai_position_lookup = set(unique_ai_positions)

    new_room = Room(
        name=room_data.name,
        num_players_N=room_data.num_players_N,
        num_non_player_nodes_M=room_data.num_non_player_nodes_M,
        points_per_round_K=room_data.points_per_round_K,
        max_turns_S=room_data.max_turns_S
    )
    global INITIAL_POINT_WEIGHT
    if INITIAL_POINT_WEIGHT is None:
        INITIAL_POINT_WEIGHT = int(
            new_room.points_per_round_K
            * new_room.num_players_N
            / new_room.num_non_player_nodes_M
            / new_room.max_turns_S
        )

    # Create Player objects with UUIDs and icons from default list
    player_ids: List[str] = []
    for i in range(new_room.num_players_N):
        pid = str(uuid.uuid4())
        # choose icon by index, wrap around if needed
        icon_name = DEFAULT_PLAYER_ICONS[i % len(DEFAULT_PLAYER_ICONS)] if DEFAULT_PLAYER_ICONS else ""
        # derive display name from icon filename (strip extension)
        display_name = icon_name.rsplit('.', 1)[0] if icon_name else f"player_{i+1}"
        player = Player(
            id=pid,
            name=display_name,
            icon=icon_name,
            is_ai=(i + 1) in ai_position_lookup,
            out_deg=(
                new_room.num_non_player_nodes_M * 2
                + new_room.num_players_N - 1) * INITIAL_POINT_WEIGHT,
            in_deg=(
                new_room.num_non_player_nodes_M * 2
                + new_room.num_players_N - 1) * INITIAL_POINT_WEIGHT
        )
        new_room.players.append(player)
        player_ids.append(pid)
    # Create Neutral objects with UUIDs and icons from default list
    neutral_ids: List[str] = []
    for i in range(new_room.num_non_player_nodes_M):
        nid = str(uuid.uuid4())
        # choose icon by index, wrap around if needed
        icon_name = DEFAULT_NEUTRAL_ICONS[i % len(DEFAULT_NEUTRAL_ICONS)] if DEFAULT_NEUTRAL_ICONS else ""
        # derive display name from icon filename
        display_name = icon_name.rsplit('.', 1)[0] if icon_name else f"neutral_{i+1}"
        neutral = Neutral(
            id=nid, name=display_name, icon=icon_name,
            out_deg=(
                new_room.num_players_N * 2
                + new_room.num_non_player_nodes_M - 1) * INITIAL_POINT_WEIGHT,
            in_deg=(
                new_room.num_players_N * 2
                + new_room.num_non_player_nodes_M - 1) * INITIAL_POINT_WEIGHT
        )
        new_room.neutrals.append(neutral)
        neutral_ids.append(nid)
    # Build graph nodes list
    all_node_ids = player_ids + neutral_ids
    # Generate simple symmetric graph edges
    edges: List[Dict[str, Any]] = []
    # self-loops
    for nid in all_node_ids:
        edges.append({"source": nid, "target": nid, "weight": 0.0})
    # player-player connections
    for i in range(len(player_ids)):
        for j in range(i+1, len(player_ids)):
            edges.append({"source": player_ids[i], "target": player_ids[j], "weight": W_PP * INITIAL_POINT_WEIGHT})
            edges.append({"source": player_ids[j], "target": player_ids[i], "weight": W_PP * INITIAL_POINT_WEIGHT})
    # player-neutral connections
    for pid in player_ids:
        for nid in neutral_ids:
            edges.append({"source": pid, "target": nid, "weight": W_PN * INITIAL_POINT_WEIGHT})
            edges.append({"source": nid, "target": pid, "weight": W_PN * INITIAL_POINT_WEIGHT})
    # neutral-neutral connections
    for i in range(len(neutral_ids)):
        for j in range(i+1, len(neutral_ids)):
            edges.append({"source": neutral_ids[i], "target": neutral_ids[j], "weight": W_NN * INITIAL_POINT_WEIGHT})
            edges.append({"source": neutral_ids[j], "target": neutral_ids[i], "weight": W_NN * INITIAL_POINT_WEIGHT})
    new_room.graph = {"nodes": [{"id": nid} for nid in all_node_ids], "edges": edges}

    # Assign spatial positions using force-directed layout
    positions = get_pos(new_room.graph["nodes"], new_room.graph["edges"])
    for player in new_room.players:
        if player.id in positions:
            x, y = positions[player.id]
            player.x, player.y = float(x), float(y)
            player.x_str = f"{int(x * 100)}%"
            player.y_str = f"{int(y * 100)}%"
    for neutral in new_room.neutrals:
        if neutral.id in positions:
            x, y = positions[neutral.id]
            neutral.x, neutral.y = float(x), float(y)
            neutral.x_str = f"{int(x * 100)}%"
            neutral.y_str = f"{int(y * 100)}%"
    new_room.graph = {"nodes": [{"id": nid} for nid in all_node_ids], "edges": edges}
    # Initialize turns list with empty adjacency matrices
    new_room.turns = {
        str(i): Turn(
                id=str(i),
                adj_matrix=[],
                completed=False
        ) for i in range(new_room.max_turns_S + 1)
    }

    # Initialize the zeroth turn's adjacency matrix
    node_ids = [node["id"] for node in new_room.graph["nodes"]]
    node_index = {name: i for i, name in enumerate(node_ids)}
    matrix_size = len(node_ids)
    adj_matrix = np.zeros((matrix_size, matrix_size))
    for edge in new_room.graph["edges"]:
        u, v = node_index[edge["source"]], node_index[edge["target"]]
        # Adjacency matrix構築時に、重みが0の場合は0.1に置き換える
        weight = max(0.1, float(edge["weight"])) # ここで0.1を加える
        adj_matrix[u, v] = weight
    new_room.turns["0"].adj_matrix = np.where(adj_matrix == 0.1, 0, adj_matrix).tolist()

    # Auto-submit AI moves before exposing the room
    populate_ai_moves(new_room)

    # Store the room
    rooms[new_room.id] = new_room

    # Logger ------------------------------------------------------------------
    logger = get_room_logger(new_room.id)
    logger.info(
        "room_started",
        extra={
            "ts": datetime.now().isoformat(timespec="milliseconds"),
            # identifiers
            "room_id": new_room.id,
            "room_name": new_room.name,
            # game parameters requested
            "num_players_N":            new_room.num_players_N,
            "num_non_player_nodes_M":   new_room.num_non_player_nodes_M,
            "points_per_round_K":       new_room.points_per_round_K,
            "max_turns_S":              new_room.max_turns_S,
            # current roster / limits (kept for backwards-compat)
            "players": [
                    {"id": p.id, "name": p.name}
                    for p in new_room.players
                ],
        },
    )
    # -------------------------------------------------------------------------
    return new_room

@app.get("/rooms", response_model=List[Room])
def get_rooms():
    return list(rooms.values())

@app.get("/rooms/{room_id}", response_model=Room)
def get_room(room_id: str):
    room = get_room_safe(room_id)
    print("Returning room from get_room:", room.dict()) # Add this line for debugging
    return room

@app.post("/rooms/{room_id}/moves", response_model=Move)
async def submit_move(room_id: str, move_in: MoveIn):
    room = get_room_safe(room_id)
    # validate player
    player = next((p for p in room.players if p.id == move_in.player_id), None)
    if player is None:
        raise HTTPException(status_code=404, detail="Player not found in this room")
    if player.is_ai:
        raise HTTPException(status_code=403, detail="AI players submit moves automatically")
    # validate points
    points_spent = abs(move_in.weight_change)
    current_spent = room.submitted_moves_points.get(move_in.player_id, 0)
    if current_spent + points_spent > room.points_per_round_K:
        raise HTTPException(status_code=400, detail="Exceeded points limit for this round")
    room.submitted_moves_points[move_in.player_id] = current_spent + points_spent
    # create move record
    new_id = max((m.id for m in room.moves), default=0) + 1
    move = Move(id=new_id, **move_in.dict())
    room.moves.append(move)
    # log
    logger = get_room_logger(room_id)
    logger.info("move", extra={"ts": datetime.now().isoformat(timespec="milliseconds"),
                          "round": room.turn,
                          "player": move.player_id,
                          "source": move.source,
                          "target": move.target,
                          "weight_change": move.weight_change})
    # broadcast update
    await broadcast_message(room_id, {"type": "move_submitted", "room": room.dict()})
    return move


@app.post("/rooms/{room_id}/reset-moves", response_model=Room)
async def reset_moves(room_id: str, request: ResetMovesRequest):
    room = get_room_safe(room_id)

    target_player = next((p for p in room.players if p.id == request.player_id), None)
    if target_player and target_player.is_ai:
        raise HTTPException(status_code=400, detail="Cannot reset moves for an AI player")

    # Filter out moves by the specified player
    room.moves = [move for move in room.moves if move.player_id != request.player_id]

    # Reset submitted points for the specified player
    if request.player_id in room.submitted_moves_points:
        room.submitted_moves_points[request.player_id] = 0

    print(f"Moves reset for player {request.player_id} in room {room_id}")
    # Logger ------------------------------------------------------------------
    logger = get_room_logger(room_id)
    logger.info(
        "reset_moves",
        extra={
            "ts": datetime.now().isoformat(timespec="milliseconds"),
            "request_player": request.player_id,
        },
    )
    # -------------------------------------------------------------------------

    # Broadcast the updated room state to all clients in the room
    await broadcast_message(room_id, {"type": "moves_reset", "room": room.dict()})
    # Return updated room to client
    return room

def ready_to_advance(room_id: str) -> bool:
    room = get_room_safe(room_id)
    # players must exist
    if not room.players:
        return False
    # must have submitted all points
    if not all(room.submitted_moves_points.get(p.id, 0) >= room.points_per_round_K for p in room.players):
        return False
    # must be on Waiting screen
    if not all(p.location == "Waiting" for p in room.players if not p.is_ai):
        return False
    return True

@app.post("/rooms/{room_id}/advance-turn", response_model=Room)
async def advance_turn(room_id: str):
    room = get_room_safe(room_id)
    # ensure all players have submitted
    if not ready_to_advance(room_id):
        raise HTTPException(status_code=400, detail="Not all players have submitted their moves yet")
    await _calculate_scores_and_advance_turn(room_id)
    return room

@app.get("/rooms/{room_id}/ready-to-advance", response_model=dict)
async def get_ready_to_advance(room_id: str):
    """
    Returns whether all players have submitted moves for the given room.
    """
    # raises HTTPException if room not found
    ready = ready_to_advance(room_id)
    return {"ready_to_advance": ready}

@app.get("/rooms/{room_id}/turns/{turn_id}/completed", response_model=dict)
async def get_turn_completed(room_id: str, turn_id: str):
    """
    Returns whether the specified turn has been completed for the given room.
    """
    room = get_room_safe(room_id)
    # Look up turn by its UUID
    turn = room.turns.get(turn_id)
    if turn is None:
        raise HTTPException(status_code=404, detail="Turn not found")
    return {"turn_completed": turn.completed}


@app.post("/rooms/{room_id}/players/{player_id}/location", response_model=Player)
async def update_player_location(
    room_id: str,
    player_id: str,
    request: LocationUpdateRequest
):
    """
    Update the UI location of a player and broadcast to all clients.
    """
    room = get_room_safe(room_id)
    for p in room.players:
        if p.id == player_id:
            if p.is_ai:
                raise HTTPException(status_code=400, detail="AI player location is managed by the server")
            p.location = request.location
            # broadcast updated location
            await broadcast_message(room_id, {
                "type": "player_location",
                "player_id": player_id,
                "location": p.location
            })
            return p
    raise HTTPException(status_code=404, detail="Player not found in this room")

@app.post("/rooms/{room_id}/players/{player_id}/rename", response_model=Player)
async def rename_player(room_id: str, player_id: str, request: RenamePlayerRequest):
    room = get_room_safe(room_id)
    print(f"rename_player called for room {room_id}, player_id {player_id}")
    print("Existing player IDs:", [p.id for p in room.players], "Names:",[p.name for p in room.players])
    for p in room.players:
        if p.id == player_id:
            p.name = request.new_name
            # Broadcast updated room state
            await broadcast_message(room_id, {"type": "player_renamed", "room": room.dict()})
            return p
    raise HTTPException(status_code=404, detail="Player not found in this room")

    return room

@app.delete("/rooms/{room_id}", status_code=204)
async def delete_room(room_id: str):
    if room_id not in rooms:
        raise HTTPException(status_code=404, detail="Room not found")

    # Notify clients in the room that it's being deleted
    await broadcast_message(room_id, {"type": "room_deleted", "detail": "This room has been deleted by the host."})

    # Clean up connections
    if room_id in connections:
        for connection in connections[room_id]:
            await connection.close(code=1000) # Normal closure
        del connections[room_id]

    # Delete the room
    if room_id in rooms:
        del rooms[room_id]
    return



@app.websocket("/ws/{room_id}")
async def websocket_endpoint(websocket: WebSocket, room_id: str):
    # Ensure room exists
    try:
        get_room_safe(room_id)
    except HTTPException:
        await websocket.close(code=4004)
        return

    await websocket.accept()
    if room_id not in connections:
        connections[room_id] = []
    connections[room_id].append(websocket)
    try:
        while True:
            # Keep connection alive, or handle messages if needed
            # For now, we just expect the client to send nothing
            await websocket.receive_text()
    except WebSocketDisconnect:
        if room_id in connections and websocket in connections[room_id]:
            connections[room_id].remove(websocket)
            if not connections[room_id]:
                del connections[room_id]
