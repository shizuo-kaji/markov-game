from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from pydantic import BaseModel, Field
from typing import List, Dict, Any
import uuid
from pathlib import Path
import numpy as np
from fastapi.middleware.cors import CORSMiddleware

import os
from datetime import datetime
from logging_conf import get_room_logger

app = FastAPI()
# Default edge weights
W_PP = 1.0  # player-player
W_NN = 1.0  # neutral-neutral
W_PN = 2.0  # player-neutral
INITIAL_POINT_WEIGHT = None  # Initial point weight for new edges

# Compute node positions in a circle
def get_pos(N, center=[0.5, 0.5], radius=0.15):
    positions = []
    for n in range(N):
        theta = 2 * np.pi * n / N
        pos = center + radius * np.array([np.cos(theta), np.sin(theta)])
        positions.append(pos)
    return positions

# Load default icon names for players and neutrals
BASE_DIR = Path(__file__).parent
try:
    with open(BASE_DIR / 'default_players.txt') as f:
        DEFAULT_PLAYER_ICONS = [line.strip() for line in f if line.strip()]
except Exception:
    DEFAULT_PLAYER_ICONS = []
try:
    with open(BASE_DIR / 'default_neutrals.txt') as f:
        DEFAULT_NEUTRAL_ICONS = [line.strip() for line in f if line.strip()]
except Exception:
    DEFAULT_NEUTRAL_ICONS = []

# Add CORS middleware
frontend_url = os.environ.get("FRONTEND_URL", "*") # Default to * for local development
app.add_middleware(
    CORSMiddleware,
    allow_origins=[frontend_url],  # Allows specific origin from environment variable
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

# --- WebSocket Connections ---
connections: Dict[str, List[WebSocket]] = {}

async def broadcast_message(room_id: str, message: Dict[str, Any]):
    if room_id in connections:
        # Create a copy of the list to avoid issues with concurrent modification
        # if a client disconnects during iteration
        for connection in list(connections[room_id]):
            try:
                await connection.send_json(message)
            except RuntimeError: # Client disconnected
                if connection in connections[room_id]:
                    connections[room_id].remove(connection)
                if not connections[room_id]:
                    del connections[room_id]

# --- Models ---
class Player(BaseModel):
    id: str
    name: str
    score: float = 0.0
    x: float = 0.0  # normalized x position (0.0 to 1.0)
    y: float = 0.0  # normalized y position (0.0 to 1.0)
    x_str: str = ""  # x as percentage string (e.g., '50%')
    y_str: str = ""  # y as percentage string
    icon: str = ""  # icon identifier for representing node
    out_deg: int = 0  # outgoing degree sum
    in_deg: int = 0   # incoming degree sum

class Neutral(BaseModel):
    id: str
    name: str
    score: float = 0.0
    x: float = 0.0
    y: float = 0.0
    x_str: str = ""
    y_str: str = ""
    icon: str = ""
    out_deg: int = 0  # outgoing degree sum
    in_deg: int = 0   # incoming degree sum

class Move(BaseModel):
    id: int  # generated by server
    player_id: str
    source: str
    target: str
    weight_change: int

class ResetMovesRequest(BaseModel):
    player_id: str

# Request schema for renaming a player
class RenamePlayerRequest(BaseModel):
    new_name: str

# Input model for creating a move without an id
class MoveIn(BaseModel):
    player_id: str
    source: str
    target: str
    weight_change: int

class Room(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str

    num_players_N: int = 1  # Default to 1 player
    num_non_player_nodes_M: int = 2 # Default to 2 non-player nodes
    points_per_round_K: int = 10 # Default to 10 points per round
    max_turns_S: int = 10 # Default to 10 turns
    players: List[Player] = []
    neutrals: List[Neutral] = []  # list of non-player nodes


    graph: Dict[str, Any] = {"nodes": [], "edges": []}
    moves: List[Move] = []
    turn: int = 1
    submitted_moves_points: Dict[str, int] = {}

# --- In-memory database ---
rooms: Dict[str, Room] = {}

# --- Helper Functions ---

def get_room_safe(room_id: str) -> Room:
    if room_id not in rooms:
        raise HTTPException(status_code=404, detail="Room not found")
    return rooms[room_id]

async def _calculate_scores_and_advance_turn(room_id: str):
    room = get_room_safe(room_id)

    # 1. Consolidate and apply moves to the graph
    consolidated_moves: Dict[tuple[str, str], int] = {}
    for move in room.moves:
        edge_key = (move.source, move.target)
        consolidated_moves[edge_key] = consolidated_moves.get(edge_key, 0) + move.weight_change

    print(f"Applying consolidated moves: {consolidated_moves}")
    for edge in room.graph["edges"]:
        edge_key = (edge["source"], edge["target"])
        if edge_key in consolidated_moves:
            net_change = consolidated_moves[edge_key]
            new_weight = int(edge["weight"] + net_change)
            edge["weight"] = max(0, new_weight)
    print("Graph after moves:", room.graph)

    # 2. Create transition matrix
    node_ids = [node["id"] for node in room.graph["nodes"]]
    node_index = {name: i for i, name in enumerate(node_ids)}
    matrix_size = len(node_ids)
    adj_matrix = np.zeros((matrix_size, matrix_size))

    for edge in room.graph["edges"]:
        u, v = node_index[edge["source"]], node_index[edge["target"]]
        # Adjacency matrix構築時に、重みが0の場合は0.1に置き換える
        weight = max(0.1, float(edge["weight"])) # ここで0.1を加える
        adj_matrix[u, v] = weight
    print("Adjacency Matrix:\n", adj_matrix)
    # Compute out/in degrees from adjacency matrix
    row_sums1d = adj_matrix.sum(axis=1)
    col_sums1d = adj_matrix.sum(axis=0)
    # Assign degrees to players
    for player in room.players:
        idx = node_index.get(player.id)
        if idx is not None:
            player.out_deg = int(row_sums1d[idx])
            player.in_deg = int(col_sums1d[idx])
    # Assign degrees to neutrals
    for neutral in room.neutrals:
        idx = node_index.get(neutral.id)
        if idx is not None:
            neutral.out_deg = int(row_sums1d[idx])
            neutral.in_deg = int(col_sums1d[idx])

    # Normalize to get transition matrix
    row_sums = adj_matrix.sum(axis=1, keepdims=True)
    print("Row Sums:\n", row_sums)
    # Avoid division by zero for isolated nodes
    row_sums[row_sums == 0] = 1
    transition_matrix = adj_matrix / row_sums
    print("Transition Matrix:\n", transition_matrix)

    # 3. Calculate stationary distribution (eigenvector for eigenvalue 1)
    eigenvalues, eigenvectors = np.linalg.eig(transition_matrix.T)
    print("Eigenvalues:\n", eigenvalues)
    print("Eigenvectors:\n", eigenvectors)
    stationary_vector = None
    for i, eigenvalue in enumerate(eigenvalues):
        if np.isclose(eigenvalue, 1):
            stationary_vector = np.real(eigenvectors[:, i])
            break

    if stationary_vector is None:
        raise HTTPException(status_code=500, detail="Could not find stationary distribution")

    stationary_distribution = stationary_vector / stationary_vector.sum()
    print("Stationary Distribution:\n", stationary_distribution)

    # 4. Update node scores from stationary distribution
    all_node_scores = {node_id: stationary_distribution[i] for node_id, i in node_index.items()}
    # Update player scores by id
    for player in room.players:
        if player.id in all_node_scores:
            player.score = all_node_scores[player.id]
            print(f"Player {player.name} ({player.id}) score updated to: {player.score}")
    # Update neutral scores by id, if needed
    for neutral in room.neutrals:
        if neutral.id in all_node_scores:
            neutral.score = all_node_scores[neutral.id]
            print(f"Neutral {neutral.name} ({neutral.id}) score updated to: {neutral.score}")

    # Logger ------------------------------------------------------------------
    logger = get_room_logger(room_id)
    logger.info(
        "scores_round",
        extra={
                "ts": datetime.now().isoformat(timespec="milliseconds"),
            "round": room.turn,
            "adj_matrix": adj_matrix.tolist(),
            "stationary_dist": stationary_distribution.tolist(),
            "scores": {p.id: p.score for p in room.players},
        },
    )
    # -------------------------------------------------------------------------

    # 5. Reset for next turn
    room.moves = []
    room.turn += 1
    room.submitted_moves_points = {}

    # Ensure graph nodes and edges are lists before broadcasting
    if "nodes" not in room.graph or not isinstance(room.graph["nodes"], list):
        room.graph["nodes"] = []
    if "edges" not in room.graph or not isinstance(room.graph["edges"], list):
        room.graph["edges"] = []

    if room.turn > room.max_turns_S: # Game over condition
        # Sort players by score for ranking
        ranked_players = sorted(room.players, key=lambda p: p.score, reverse=True)
        game_over_message = {
            "type": "game_over",
            "room": room.dict(),
            "ranking": [{"id": p.id, "name": p.name, "score": p.score} for p in ranked_players],
            "all_node_scores": all_node_scores
        }

        # Logger --------------------------------------------------------------
        logger.info(
            "game_over",
            extra={
                "ts": datetime.now().isoformat(timespec="milliseconds"),
                "final_ranking": [
                    {"id": p.id, "name": p.name, "score": p.score}
                    for p in ranked_players
                ],
            },
        )
        # ---------------------------------------------------------------------

        await broadcast_message(room_id, game_over_message)
        # Room deletion is handled via the DELETE /rooms/{room_id} endpoint
    else:
        await broadcast_message(room_id, {"type": "scores_calculated", "room": room.dict()})


# --- API Endpoints ---

@app.get("/")
def read_root():
    return {"message": "Welcome to Markovian Royale API"}

class RoomCreate(BaseModel):
    name: str

    num_players_N: int = 2
    num_non_player_nodes_M: int = 2
    points_per_round_K: int = 10
    max_turns_S: int = 10

@app.post("/rooms", response_model=Room, status_code=201)
@app.post("/rooms", response_model=Room, status_code=201)
def create_room(room_data: RoomCreate):
    new_room = Room(
        name=room_data.name,
        num_players_N=room_data.num_players_N,
        num_non_player_nodes_M=room_data.num_non_player_nodes_M,
        points_per_round_K=room_data.points_per_round_K,
        max_turns_S=room_data.max_turns_S
    )
    global INITIAL_POINT_WEIGHT
    if INITIAL_POINT_WEIGHT is None:
        INITIAL_POINT_WEIGHT = int(
            new_room.points_per_round_K 
            * new_room.num_players_N
            / new_room.num_non_player_nodes_M
            / new_room.max_turns_S
        )

    # Create Player objects with UUIDs and icons from default list
    player_ids: List[str] = []
    for i in range(new_room.num_players_N):
        pid = str(uuid.uuid4())
        # choose icon by index, wrap around if needed
        icon_name = DEFAULT_PLAYER_ICONS[i % len(DEFAULT_PLAYER_ICONS)] if DEFAULT_PLAYER_ICONS else ""
        # derive display name from icon filename (strip extension)
        display_name = icon_name.rsplit('.', 1)[0] if icon_name else f"player_{i+1}"
        player = Player(
            id=pid, 
            name=display_name, 
            icon=icon_name,
            out_deg=(
                new_room.num_non_player_nodes_M * 2 
                + new_room.num_players_N - 1) * INITIAL_POINT_WEIGHT,
            in_deg=(
                new_room.num_non_player_nodes_M * 2 
                + new_room.num_players_N - 1) * INITIAL_POINT_WEIGHT
        )
        new_room.players.append(player)
        player_ids.append(pid)
    # Create Neutral objects with UUIDs and icons from default list
    neutral_ids: List[str] = []
    for i in range(new_room.num_non_player_nodes_M):
        nid = str(uuid.uuid4())
        # choose icon by index, wrap around if needed
        icon_name = DEFAULT_NEUTRAL_ICONS[i % len(DEFAULT_NEUTRAL_ICONS)] if DEFAULT_NEUTRAL_ICONS else ""
        # derive display name from icon filename
        display_name = icon_name.rsplit('.', 1)[0] if icon_name else f"neutral_{i+1}"
        neutral = Neutral(
            id=nid, name=display_name, icon=icon_name,
            out_deg=(
                new_room.num_players_N * 2
                + new_room.num_non_player_nodes_M - 1) * INITIAL_POINT_WEIGHT,
            in_deg=(
                new_room.num_players_N * 2
                + new_room.num_non_player_nodes_M - 1) * INITIAL_POINT_WEIGHT
        )
        new_room.neutrals.append(neutral)
        neutral_ids.append(nid)
    # Assign spatial positions (normalized and percentage) for players and neutrals
    # Players on radius 0.35
    player_positions = get_pos(new_room.num_players_N, center=[0.5, 0.5], radius=0.35)
    for idx, player in enumerate(new_room.players):
        x, y = player_positions[idx]
        player.x, player.y = float(x), float(y)
        player.x_str = f"{int(x * 100)}%"
        player.y_str = f"{int(y * 100)}%"
    # Neutrals on smaller radius 0.12
    neutral_positions = get_pos(new_room.num_non_player_nodes_M, center=[0.5, 0.5], radius=0.12)
    for idx, neutral in enumerate(new_room.neutrals):
        x, y = neutral_positions[idx]
        neutral.x, neutral.y = float(x), float(y)
        neutral.x_str = f"{int(x * 100)}%"
        neutral.y_str = f"{int(y * 100)}%"
    # Build graph nodes list
    all_node_ids = player_ids + neutral_ids
    # Generate simple symmetric graph edges
    edges: List[Dict[str, Any]] = []
    # self-loops
    for nid in all_node_ids:
        edges.append({"source": nid, "target": nid, "weight": 0.0})
    # player-player connections
    for i in range(len(player_ids)):
        for j in range(i+1, len(player_ids)):
            edges.append({"source": player_ids[i], "target": player_ids[j], "weight": W_PP * INITIAL_POINT_WEIGHT})
            edges.append({"source": player_ids[j], "target": player_ids[i], "weight": W_PP * INITIAL_POINT_WEIGHT})
    # player-neutral connections
    for pid in player_ids:
        for nid in neutral_ids:
            edges.append({"source": pid, "target": nid, "weight": W_PN * INITIAL_POINT_WEIGHT})
            edges.append({"source": nid, "target": pid, "weight": W_PN * INITIAL_POINT_WEIGHT})
    # neutral-neutral connections
    for i in range(len(neutral_ids)):
        for j in range(i+1, len(neutral_ids)):
            edges.append({"source": neutral_ids[i], "target": neutral_ids[j], "weight": W_NN * INITIAL_POINT_WEIGHT})
            edges.append({"source": neutral_ids[j], "target": neutral_ids[i], "weight": W_NN * INITIAL_POINT_WEIGHT})
    new_room.graph = {"nodes": [{"id": nid} for nid in all_node_ids], "edges": edges}
    # Store the room
    rooms[new_room.id] = new_room

    # Logger ------------------------------------------------------------------
    logger = get_room_logger(new_room.id)
    logger.info(
        "room_started",
        extra={
            "ts": datetime.now().isoformat(timespec="milliseconds"),
            # identifiers
            "room_id": new_room.id,
            "room_name": new_room.name,
            # game parameters requested
            "num_players_N":            new_room.num_players_N,
            "num_non_player_nodes_M":   new_room.num_non_player_nodes_M,
            "points_per_round_K":       new_room.points_per_round_K,
            "max_turns_S":              new_room.max_turns_S,
            # current roster / limits (kept for backwards-compat)
            "players": [
                    {"id": p.id, "name": p.name}
                    for p in new_room.players
                ],
        },
    )
    # -------------------------------------------------------------------------
    return new_room

@app.get("/rooms", response_model=List[Room])
def get_rooms():
    return list(rooms.values())

@app.get("/rooms/{room_id}", response_model=Room)
def get_room(room_id: str):
    room = get_room_safe(room_id)
    print("Returning room from get_room:", room.dict()) # Add this line for debugging
    return room

@app.post("/rooms/{room_id}/moves", response_model=Move)
async def submit_move(room_id: str, move_in: MoveIn):
    room = get_room_safe(room_id)
    # validate player
    player_ids = {p.id for p in room.players}
    if move_in.player_id not in player_ids:
        raise HTTPException(status_code=404, detail="Player not found in this room")
    # validate points
    points_spent = abs(move_in.weight_change)
    current_spent = room.submitted_moves_points.get(move_in.player_id, 0)
    if current_spent + points_spent > room.points_per_round_K:
        raise HTTPException(status_code=400, detail="Exceeded points limit for this round")
    room.submitted_moves_points[move_in.player_id] = current_spent + points_spent
    # create move record
    new_id = max((m.id for m in room.moves), default=0) + 1
    move = Move(id=new_id, **move_in.dict())
    room.moves.append(move)
    # log
    logger = get_room_logger(room_id)
    logger.info("move", extra={"ts": datetime.now().isoformat(timespec="milliseconds"),
                          "round": room.turn,
                          "player": move.player_id,
                          "source": move.source,
                          "target": move.target,
                          "weight_change": move.weight_change})
    # broadcast update
    await broadcast_message(room_id, {"type": "move_submitted", "room": room.dict()})
    return move


@app.post("/rooms/{room_id}/reset-moves", response_model=Room)
async def reset_moves(room_id: str, request: ResetMovesRequest):
    room = get_room_safe(room_id)

    # Filter out moves by the specified player
    room.moves = [move for move in room.moves if move.player_id != request.player_id]

    # Reset submitted points for the specified player
    if request.player_id in room.submitted_moves_points:
        room.submitted_moves_points[request.player_id] = 0

    print(f"Moves reset for player {request.player_id} in room {room_id}")
    # Logger ------------------------------------------------------------------
    logger = get_room_logger(room_id)
    logger.info(
        "reset_moves",
        extra={
            "ts": datetime.now().isoformat(timespec="milliseconds"),
            "request_player": request.player_id,
        },
    )
    # -------------------------------------------------------------------------

    # Broadcast the updated room state to all clients in the room
    await broadcast_message(room_id, {"type": "moves_reset", "room": room.dict()})
    # Return updated room to client
    return room

def ready_to_advance(room_id: str) -> bool:
    room = get_room_safe(room_id)
    # This was extracted from the advance_turn endpoint
    if not room.players or not all(room.submitted_moves_points.get(p.id, 0) >= room.points_per_round_K for p in room.players):
        return False
    return True

@app.post("/rooms/{room_id}/advance-turn", response_model=Room)
async def advance_turn(room_id: str):
    room = get_room_safe(room_id)
    # ensure all players have submitted
    if not ready_to_advance(room_id):
        raise HTTPException(status_code=400, detail="Not all players have submitted their moves yet")
    await _calculate_scores_and_advance_turn(room_id)
    return room

@app.get("/rooms/{room_id}/ready-to-advance", response_model=dict)
async def get_ready_to_advance(room_id: str):
    """
    Returns whether all players have submitted moves for the given room.
    """
    # raises HTTPException if room not found
    ready = ready_to_advance(room_id)
    return {"ready_to_advance": ready}

@app.post("/rooms/{room_id}/players/{player_id}/rename", response_model=Player)
async def rename_player(room_id: str, player_id: str, request: RenamePlayerRequest):
    room = get_room_safe(room_id)
    print(f"rename_player called for room {room_id}, player_id {player_id}")
    print("Existing player IDs:", [p.id for p in room.players], "Names:",[p.name for p in room.players])
    for p in room.players:
        if p.id == player_id:
            p.name = request.new_name
            # Broadcast updated room state
            await broadcast_message(room_id, {"type": "player_renamed", "room": room.dict()})
            return p
    raise HTTPException(status_code=404, detail="Player not found in this room")

    return room

@app.delete("/rooms/{room_id}", status_code=204)
async def delete_room(room_id: str):
    if room_id not in rooms:
        raise HTTPException(status_code=404, detail="Room not found")

    # Notify clients in the room that it's being deleted
    await broadcast_message(room_id, {"type": "room_deleted", "detail": "This room has been deleted by the host."})

    # Clean up connections
    if room_id in connections:
        for connection in connections[room_id]:
            await connection.close(code=1000) # Normal closure
        del connections[room_id]

    # Delete the room
    if room_id in rooms:
        del rooms[room_id]
    return



@app.websocket("/ws/{room_id}")
async def websocket_endpoint(websocket: WebSocket, room_id: str):
    # Ensure room exists
    try:
        get_room_safe(room_id)
    except HTTPException:
        await websocket.close(code=4004)
        return

    await websocket.accept()
    if room_id not in connections:
        connections[room_id] = []
    connections[room_id].append(websocket)
    try:
        while True:
            # Keep connection alive, or handle messages if needed
            # For now, we just expect the client to send nothing
            await websocket.receive_text()
    except WebSocketDisconnect:
        if room_id in connections and websocket in connections[room_id]:
            connections[room_id].remove(websocket)
            if not connections[room_id]:
                del connections[room_id]
